# 정규화

- ### 정규화(Normalization)

  > 관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스를 **정규화**라고 한다.

  조금 더 이론적으로 접근해 보면 함수적 종속성을 이용해서 연관성 있는 속성들을 분류하고, 각 릴레이션들에서 이상현상이 생기지 않도록 하는 과정을 말한다.

  정규화 된 정도를 정규형(Normal Form) 으로 표현하는데, 정규형에는 1NF, 2NF, 3NF, BCNF, 4NF, 5NF, 6NF 까지 있다. 비공식적 표현으로는 3NF 가 되었으면 정규화 되었다고 말한다. 3NF 테이블의 대부분이 삽입, 변경, 삭제 이상이 없으며, 3NF 테이블의 대부분이 BCNF, 4NF, 5NF이다.

  각 정규형이 되기 위해서는 만족시켜야 할 제약조건들이 있다. 높은 차수의 정규형으로 갈 수록 조건이 까다롭다.

  

  ### 제 1 정규형 (1NF; First Normal Form)

  > 릴레이션에 속한 모든 속성의 도메인이 원자 값으로만 구성되어 있으면 **제1정규형**에 속한다.

  | **STUDENT_ID** |          **COURSE_ID**          |   GRADE   | STUDENT_NM |
  | :------------: | :-----------------------------: | :-------: | :--------: |
  |    20800399    | CSE011101, CSE022202, CSE033303 | A+, A, B+ |    야붕    |

  위와같은 형태의 릴레이션은 제1정규형을 만족하지 않는다. 최소한 아래와 같은 형태가 되어야 제1정규형을 만족한다고 할 수 있다.

  관계형 데이터베이스의 릴레이션은 모든 속성이 원자 값을 가지는 특성이 있기 때문에, 최소한 제1정규형을 만족해야 릴레이션이 될 자격이 있다.

  | **STUDENT_ID** | **COURSE_ID** | GRADE | STUDENT_NM |
  | :------------: | :-----------: | :---: | :--------: |
  |    20800399    |   CSE011101   |  A+   |    야붕    |
  |    20800399    |   CSE022202   |   A   |    야붕    |
  |    20800399    |   CSE033303   |  B+   |    야붕    |

  

  ### 제 2 정규형 (2NF; Second Normal Form)

  제1정규형만 만족시키는 릴레이션에서 부분 함수 종속성을 가지게 되는 경우 삽입이상, 갱신이상, 삭제이상 세가지 이상현상이 모두 나타나게 된다.

  > 제1정규형에 속하면서,
  > 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속되면 **제2정규형**이다.

  제2정규형 부터는 아래 릴레이션으로 설명해본다.

  | **학번** | **과목코드** | 성적 |     학부     | 등록금 |
  | :------: | :----------: | :--: | :----------: | :----: |
  | 20800399 |  CSE011101   |  A+  | 컴퓨터공학부 |  350   |
  | 20800399 |  CSE022202   |  A   | 컴퓨터공학부 |  350   |
  | 20800399 |  CSE033303   |  B+  | 컴퓨터공학부 |  350   |
  | 21300758 |  MEC011101   |  F   |   경영학부   |  300   |
  | 21400001 |  POD032939   |  C+  |  기계공학부  |  400   |
  | 21500399 |  CSE011101   |  D   | 컴퓨터공학부 |  350   |

  

  위 릴레이션의 함수적 종속성을 살펴보면 아래와 같다.

  > {학번, 과목코드} -> 성적
  > {학번, 과목코드} -> 학부
  > {학번, 과목코드} -> 등록금
  > 학번 -> 학부
  > 학번 -> 등록금
  > 학부 -> 등록금

  현재 학번->학부, 학번->등록금 두개의 부분 함수 종속성을 가지고 있다. 이를 제거해 주는 것을 제2정규화라고 한다.

  학번, 학부, 등록금 속성을 가지는 학생 릴레이션과 학번, 과목코드, 성적 속성을 가지는 성적릴레이션 둘로 나누어 주면 부분 함수 종속성을 제거할 수 있다.

  학번->학부 함수종속성으로 볼때, 학번만으로 학부에 대한 결정을 지을 수 있다는 말이다. 그러나 현재 기본키가 학번, 과목코드로 이루어져 있기 때문에 학번만으로 학부에 대한 결정을 지을 수 있다는 게 의미가 없어진다. 그래서 이를 가능하도록 해주는 과정이 부분 함수 종속성을 제거하는 제2정규화 과정이다.

  여기서 학부->등록금 이라는 함수적 종속성은 부분 함수 종속성이 아니다. X -> Y 라는 함수적 종속성에서 부분 함수 종속성, 완전 함수 종속성을 따질 때 결정자 X가 반드시 기본키나 후보키에 속할 필요는 없으므로 현재 학부->등록금 의 함수 종속은 하나의 완전 함수 종속이라고 볼 수 있다.

  

  학번->학부, 학번->등록금 두개의 부분 함수 종속성을 제거하여 분리한 두개의 릴레이션은 아래와 같다.

  학생 릴레이션

  | **학번** |     학부     | 등록금 |
  | :------: | :----------: | :----: |
  | 20800399 | 컴퓨터공학부 |  350   |
  | 21300758 |   경영학부   |  300   |
  | 21400001 |  기계공학부  |  400   |
  | 21500399 | 컴퓨터공학부 |  350   |

  성적 릴레이션

  | **학번** | **과목코드** | 성적 |
  | :------: | :----------: | :--: |
  | 20800399 |  CSE011101   |  A+  |
  | 20800399 |  CSE022202   |  A   |
  | 20800399 |  CSE033303   |  B+  |
  | 21300758 |  MEC011101   |  F   |
  | 21400001 |  POD032939   |  C+  |
  | 21500399 |  CSE011101   |  D   |

  릴레이션이 둘로 분해되면서 학부와 등록금에 대한 중복항목이 제거되었다. 정규화 과정에서 주의할 점은 정규화를 통해 분해된 릴레이션들이 조인을 통해 원래의 구조로 복원될 수 있어야 한다는 것이다.

  두 릴레이션 모두 제1정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속되므로 제2정규형을 만족한다.

  > 제 2 정규형을 만족하면 이상현상이 없어질까?

  그렇지 않다.

  **삽입이상**
  새로운 학부가 생기는 경우 등록된 학생(학번)이 없다면 학번속성이 NULL이 되므로 삽입할 수 없다.

  **갱신이상**
  컴퓨터공학부 등록금이 400으로 오르는 경우 20800399, 21500399 둘 모두 바꾸어 주지 않으면 데이터 불일치 문제가 발생한다.

  **삭제이상**
  21400001 학번을 가진 학생이 자퇴하는 경우, 기계공학부에 대한 정보가 함께 사라진다.

  제2정규형에서도 이상현상이 발생하는 이유는 이행적 함수 종속이 존재하기 때문이다. 이행적 함수 종속을 없애주는 과정이 제 3 정규화이다.

  

  ### 제 3 정규형 (3NF; Third Normal Form)

  > 제 2 정규형에 속하면서,
  > 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않으면 **제 3 정규형**이다.

  **이행(移行)적 함수 종속 (Transitive Functional Dependency)**
  이행적? 뭔가 와닿지 않아서 transitive 뜻을 찾아봤더니 ‘타동사의’ 라는 뜻이.. 있는데 드물게 ‘옮아가는’ 이라는 의미로도 쓰인다. 옮길 이, 다닐 행 자를 써서 옮기고 다닌다? 뭐 이런 뜻같다.

  그래서 이행적 함수 종속이라는 게 뭐냐하면 삼단논법 같은 관계를 가진 함수종속이다. X, Y, Z 에 대해 X->Y 이고 Y->Z 이면 X->Z 가 성립한다. 이를 Z 가 X 에 이행적으로 함수 종속되었다고 한다.

  지금 학생 릴레이션에서 함수적 종속성은 아래와 같다.

  > 학번 -> 학부
  > 학부 -> 등록금
  > 학번 -> 등록금

  논리적으로 말은 되는데 의미상 뭔가 이상하다. 학부에 따라 등록금이 결정되는 것이지 학번에 따라 결정되는 것은 아니다. 그냥 이걸 둘로 분리 해주면 된다.

  > X->Y, Y->Z 함수적 종속관계로 인해 X->Z 의 이행적 함수 종속 관계가 나타나면 [X, Y], [Y, Z] 두 릴레이션으로 분해한다.

  분리하여 이행적 종속 관계를 제거 한 학생 릴레이션과 학부 릴레이션은 아래와 같다.

  ![정규화-1](https://github.com/Songwonseok/CS-Study/blob/main/Database/images/%EC%A0%95%EA%B7%9C%ED%99%94-1.png)

  > 제 3 정규형을 만족하면 이상현상이 없어질까?

  그렇지 않다.

  지금까지 살펴본 세가지 릴레이션에서는 기본키가 될 수 있는 후보키가 하나 밖에 없었다. 하지만 후보키를 여러개 가지고 있는 릴레이션에서는 제3정규형을 만족하더라도 이상현상이 생길 수 있다.

  이를 해결하기 위한 정규형이 보이스-코드 정규형 (BCNF; Boyce-Codd Normal Form)이다. 제3정규형보다 조금 더 엄격한 제약조건을 가지기 때문에 Strong 3NF 라고도 한다.



### 3NF 면 BCNF 이다?

3NF 를 만족하는 릴레이션 R의 후보키가 1개 밖에 없고, R의 후보키가 기본키가 되고, 3NF를 만족하면 항상 BCNF 를 만족한다. 즉, 3NF 를 만족하는 릴레이션들은 모두 후보키가 1개 밖에 없었기 때문에 3NF 를 만족시키는 정규화를 했지만 BCNF 도 만족한다.

하지만 후보키가 여러개인 경우에는 3NF를 만족시키지만 이상현상이 발생하는 경우가 있는데, 이를 해결하기 위한 정규형이 보이스-코드 정규형 (BCNF; Boyce-Codd Normal Form)이다. 제3정규형보다 조금 더 엄격한 제약조건을 가지기 때문에 Strong 3NF 라고도 한다.



### BCNF (Boyce-Codd Normal Form)

이론적으로는 아래 조건을 만족시키는 릴레이션은 BCNF 라고 한다.

> X -> Y 는 trivial FD 이거나, X 는 릴레이션 R 의 슈퍼키이다.

Trivial FD 는 Y 가 X 의 부분집합인 경우를 말한다. A->A 이거나 AB->A 같은 당연한 경우를 말하는 것이다. 그래서 BCNF 에 대한 정의를 실용적인 말로 바꾸면 "모든 결정자가 KEY 인 경우 **BCNF** 이다" 라고 할 수 있겠다. BCNF 를 위반하는 릴레이션은 이론적으로는 아래와 같은 구조를 가지게 된다. (A, B 가 키)

![정규화-2](https://github.com/Songwonseok/CS-Study/blob/main/Database/images/%EC%A0%95%EA%B7%9C%ED%99%94-2.png)

위 릴레이션은 1NF 는 만족한다는 가정하에,

- 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속이므로 2NF 를 만족한다.
- 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않으므로 3NF 를 만족한다.

하지만, 결정자인 C 가 슈퍼키가 아니다. 그러므로 BCNF 를 위반한다. A, B, C 속성만 사용해서 예제를 만들어보자.



### BCNF 를 위반하는 사례

![정규화-3](https://github.com/Songwonseok/CS-Study/blob/main/Database/images/%EC%A0%95%EA%B7%9C%ED%99%94-3.png)

BCNF 위반 예제

키로 사용될 수 있는 속성은 {Student, Course} 혹은 {Course, Instructor} 가 될 수 있다. 이 중에서 {Student, Course} 를 기본키로 선정했다.

3NF 까지 만족하지만 BCNF 를 만족하지 않는 경우에도 삽입이상, 갱신이상, 삭제이상이 생길 수 있다.

**삽입이상**
Algorithms 라는 수업이 Dijkstra 에 의해 열렸다고 하자. 하지만 수강생이 아무도 없는 경우 삽입할 수 없다.

**갱신이상**
James Gosling 이 담당하는 강의가 바뀌게 될 경우 수강생의 수만큼 갱신해줘야 하므로 하나라도 빠뜨리면 데이터 불일치 문제가 발생할 여지가 있다.

**삭제이상**
모찌가 자퇴해서 Computer Architecture 수업의 수강생이 없어지면 Alan Turing 이라는 강사도 사라진다.



### 분해

BCNF 를 위반하는 릴레이션에 대한 분해과정은 아래와 같다.

- BCNF 를 위반하는 nontrivial FD X -> Y 를 찾는다.
- 두 개의 릴레이션으로 분해한다.
  - XY 로 구성된 릴레이션 하나
  - X 와 나머지 속성들로 구성된 릴레이션 하나

위 과정을 Student, Course, Instructor 예제에 적용시키면 아래와 같다.

- nontrivial FD Instructor -> Course 를 찾았다.
- 두 개의 릴레이션으로 분해한다.
  - Instructor, Course 하나
  - Instructor 와 나머지 속성들로 구성된 릴레이션 Instructor, Student

분해한 두 개의 릴레이션에서 기존 릴레이션에서 결정자역할을 했던 속성을 키로 해준다. 그러면 BCNF 까지 만족시키는 릴레이션 두 개가 생기게 된다.

![정규화-4](https://github.com/Songwonseok/CS-Study/blob/main/Database/images/%EC%A0%95%EA%B7%9C%ED%99%94-4.png)

BCNF를 만족하는 두개의 릴레이션으로 분해



### 하고보니 드는 의문점

BCNF 를 위반하는 좀 더 현실적인 예제를 찾기위해 애썼는데 저게 최선이었다. 근데 내가 못찾는거거나 사람들이 몰라서 안올린게 아니라 그런 경우가 잘 없을 것 같다는 생각이 들었다. 의미를 공유하는 속성들을 제대로 잘 분리하여 3정규형 까지 왔으면 BCNF 를 만족시키지 않는 형태가 나오는 것 자체가 애초에 관심사를 잘못 분리해 온 경우가 아닌가 싶다.

위 예제를 봐도, 최종 테이블의 형태가 좀 어색하다. 학생이 수강한 내역을 과목에 대응시키는 것이 의미상으로 맞는 것이지 강사에 대응시키는 것은 뭔가 어색하다.

내 개인적인 생각으로는 BCNF 를 위반하는 예제에 사용했던 릴레이션이 그 자체로 문제가 있다기 보다는 이 릴레이션에 모든것을 담으려다 보니까 생긴 문제라고 생각한다. DBA 이거나 전문가가 아니라서 현실세계에서 어떤 경우가 더 많이 발생하고 채택되는지 정확히 알 수는 없지만, BCNF 를 위반하는 경우 자체가 이론적으로 접근할 때에만 많이 생기는 것 같다. (AB->C, C->B 의 FD 를 가지는 실생활 예제를 찾으려고 계속 생각해봐도 참 안떠오르고 떠오른다고 해도 억지스럽고 어색하다)

위 예제 같은 경우 애초에

- 과목ID를 키로 가지는 과목 테이블이 있을테고
- 학생ID를 키로 가지는 학생 테이블이 있을테고
- 강사ID를 키로 가지는 강사 테이블이 있어야 할 것이다.

그렇게 세 테이블이 추가적으로 존재하고, BCNF 를 만족하지 않았던 테이블의 데이터가 과목ID, 학생ID, 강사ID 를 외래키로 가진다면, BCNF 를 만족하는 어색한 테이블 두개를 만들어내는 방법에서 각종 이상현상을 해소했던 것처럼 이상현상을 해소할 수 있다.

처음부터 잘못 설계 된 구조로 시스템을 운영하다가 어떤 기능을 추가하려고 하다보니 BCNF 를 위반하는 사례는 어쩌면 생길 수도 있을 것 같지만, 아무리 생각해도 BCNF 를 위반하는 사례는 이론적으로만 많이 존재할 것 같다.



### 참고
http://itwiki.kr/w/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EC%A0%95%EA%B7%9C%ED%99%94

https://yaboong.github.io/database/2018/03/09/database-normalization-1/

https://minimax95.tistory.com/entry/%EC%A0%95%EA%B7%9C%ED%99%94Normalization-%EA%B0%9C%EB%85%90%EA%B3%BC-%EA%B8%B0%EB%B3%B8-%EA%B3%BC%EC%A0%95